---
title: "Slide-tags Mouse Embryonic Brain snAnalysis"
author: "L. Franzén"
format: html
editor: visual
---

## The data

Using the original published Slide-tags snRNA-seq data for mouse embryonic brain.

Publication: Russell, A.J.C., Weir, J.A., Nadaf, N.M. *et al.* Slide-tags enables single-nucleus barcoding for multimodal spatial genomics. *Nature* **625**, 101–109 (2024). https://doi.org/10.1038/s41586-023-06837-4

Data downloaded from here (February 2025): <https://singlecell.broadinstitute.org/single_cell/study/SCP2170/slide-tags-snrna-seq-on-mouse-embryonic-e14-brain?#study-download>

## Set up

```{r}
library(Seurat)
library(tidyverse)
library(patchwork)
library(paletteer)
```

```{r}
PROJECT_ID <- "mouse_embryonic_brain"
DIR_ROOT <- file.path(getwd(), "..")
DIR_DATA <- file.path(DIR_ROOT, "data", PROJECT_ID)
DIR_RES <- file.path(DIR_ROOT, "results", PROJECT_ID)
```

```{r}
list.files(DIR_DATA)
```

## Read Slide-tags data

```{r}
mouse_embryo_data <- Read10X(file.path(DIR_DATA, "expression"))
se_embryo <- CreateSeuratObject(mouse_embryo_data)
```

```{r}
embryo_mdat_clusters <- read.csv(file.path(DIR_DATA, "cluster", "mouseembryo_cluster.csv"), 
                                 header = T) |> 
  filter(!row_number() %in% c(1)) |> 
  mutate(across(c(2:3), ~ as.numeric(.)))

embryo_mdat_spatial <- read.csv(file.path(DIR_DATA, "cluster", "mouseembryo_spatial.csv"), 
                                 header = T) |> 
  filter(!row_number() %in% c(1)) |> 
  mutate(across(c(2:3), ~ as.numeric(.)))
```

```{r}
dim(embryo_mdat_clusters)
dim(embryo_mdat_spatial)
```

```{r}
colnames(embryo_mdat_clusters) <- c("barcode", "UMAP_1", "UMAP_2", "cell_type")
colnames(embryo_mdat_spatial) <- c("barcode", "spatial_x", "spatial_y", "cell_type")
```

```{r}
embryo_mdat <- merge(embryo_mdat_clusters, embryo_mdat_spatial[, 1:3], by = "barcode")
rownames(embryo_mdat) <- embryo_mdat$barcode
head(embryo_mdat)
```

```{r fig.width=16, fig.height=6}
ggplot(embryo_mdat, aes(x=UMAP_1, y=UMAP_2, fill=cell_type)) +
  geom_point(shape=21) & 
  # scale_fill_manual(values = palcetteer_d("ggsci::category20_d3", n = 20)) &
  theme(aspect.ratio = 1) |
  ggplot(embryo_mdat, aes(x=spatial_x, y=spatial_y, fill=cell_type)) +
    geom_point(shape=21) &
    # scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
    theme(aspect.ratio = 1)
```

```{r}
se_embryo <- AddMetaData(se_embryo, metadata = embryo_mdat)
```

```{r fig.width=10, fig.height=6}
VlnPlot(se_embryo, features = c("nCount_RNA", "nFeature_RNA"), group.by = "cell_type")
```

## Read reconstructed data

```{r}
# embryo_recon <- read.csv(file.path(DIR_DATA, "reconstructed",
#                                    "full_reconstruction_summary.csv")) |> 
#   filter(!node_type == "bead") |> 
#   select(!node_ID)

embryo_recon <- read.csv(file.path(DIR_DATA, "reconstructed",
                                   "full_reconstruction_summary_subgraph_1_N=61180_mouse_embryo.csv")) |>
  filter(!node_type == "bead") |> 
  select(!node_ID)

dim(embryo_recon); head(embryo_recon)
```

```{r}
rownames(embryo_recon) <- paste0(embryo_recon$node_bc, "-1")
```

```{r fig.width=10, fig.height=6}
# ggplot(embryo_recon, aes(x=gt_x, y=gt_y, fill=cell_type)) +
#     geom_point(shape=21) & 
#     scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
#     labs(title = "Ground truth") &
#     theme(aspect.ratio = 1, legend.position = "none") |
ggplot(embryo_recon, aes(x=align_recon_x_1, y=align_recon_y_1, fill=node_type)) +
  geom_point(shape=21) & 
  # scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
  labs(title = "Recon. 1") &
  theme(aspect.ratio = 1, legend.position = "none") |
  ggplot(embryo_recon, aes(x=morph_recon_x_1, y=morph_recon_y_1, fill=node_type)) +
    geom_point(shape=21) & 
    # scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
    labs(title = "Recon. 1") &
    theme(aspect.ratio = 1, legend.position = "bottom")
```

```{r}
se_embryo <- AddMetaData(se_embryo, metadata = embryo_recon |> select(-c(1)))
```

```{r}
is.na(se_embryo$cell_type) |> sum()

is.na(se_embryo$recon_x_1) |> sum()

head(se_embryo@meta.data)
```

Remove cells without any reconstructed positions

```{r}
dim(se_embryo)
cells_remove <- se_embryo$recon_x_1[is.na(se_embryo$recon_x_1)] |> names(); length(cells_remove)
cells_keep <- colnames(se_embryo)[!colnames(se_embryo) %in% cells_remove]; length(cells_keep)
```

```{r}
se_embryo <- subset(se_embryo, cells = cells_keep)
```

## Slide-tags data re-analysis

See if I can rerun the filtering and clustering of the data and obtain same/similar cell type clusters as originally presented in the paper:

> **Quality control and cell type assignment**
>
> The output generated by Cell Ranger and filtered by CellBender was read into R (v.4.1.1) using Seurat (v.4.3.0).
>
> We normalized the total UMIs per nucleus to 10,000 (CP10K) and log-transformed these values to report gene expression as E = log\[CP10K + 1\].
>
> We identified the top 2,000 highly variable genes after using variance-stabilizing transformation correction.
>
> All gene expression values were scaled and centred.
>
> For visualization in two dimensions, we embedded nuclei in a UMAP using the top 30 principal components, with number of neighbours =40, min_dist = 0.3, spread =15, local connectivity = 12 and the cosine distance metric.
>
> We identified shared nearest neighbours using the top 30 principal components.
>
> Clusters of similar cells were detected using the Louvain method for community detection, implemented using FindClusters, with resolution = 0.8.

Mapping of cell types was performed using a mouse embryo E14 reference dataset and applying the FindTransferAnchors followed by the TransferData, based on the first 25 principal components, functions from Seurat. Identities were assigned using the highest proportion of the transferred labels.

```{r}
embryo_mdat$cell_type |> unique() |> length()
```

### Filter data

There doesn't seem to be much information regarding filtering. In the cell type metadata, there are 5778 cells, however, in the full data set there are 9360 cells.

```{r}
se_embryo_orig <- subset(se_embryo, cells = embryo_mdat$barcode)

new_cells <- filter(se_embryo@meta.data, !barcode %in% embryo_mdat$barcode) |> rownames()
se_embryo_new <- subset(se_embryo, cells = new_cells)
```

### Process

```{r}
se_embryo_orig <- NormalizeData(se_embryo_orig, 
                                scale.factor = 10000)
```

```{r}
se_embryo_orig <- FindVariableFeatures(se_embryo_orig, 
                                       nfeatures = 2000, 
                                       selection.method = 'vst')
```

```{r}
se_embryo_orig <- ScaleData(se_embryo_orig, 
                            do.scale = T, 
                            do.center = T)
```

### Dim reduction & clustering

```{r}
se_embryo_orig <- RunPCA(se_embryo_orig)
```

```{r fig.width=6, fig.height=4}
ElbowPlot(se_embryo_orig, ndims = 50)
```

```{r fig.width=14, fig.height=18}
DimHeatmap(se_embryo_orig, reduction = "pca", dims = 1:30, ncol = 5)
DimHeatmap(se_embryo_orig, reduction = "pca", dims = 31:50, ncol = 5)
```

```{r}
# n_dims <- 30
n_dims <- 20
```

```{r}
se_embryo_orig <- RunUMAP(se_embryo_orig, 
                          dims = 1:n_dims, 
                          reduction = "pca", 
                          n.neighbors = 40, 
                          min.dist = 0.3, 
                          spread = 15, 
                          local.connectivity = 12)
```

```{r}
se_embryo_orig <- FindNeighbors(se_embryo_orig, dims = 1:n_dims, reduction = "pca", compute.SNN = T)
se_embryo_orig <- FindClusters(se_embryo_orig, resolution = 0.8)
```

### Plot and annotate clusters

```{r fig.width=14, fig.height=6}
DimPlot(se_embryo_orig, reduction = "umap", group.by = "seurat_clusters") & 
  labs(title="New cell clusters") |
  DimPlot(se_embryo_orig, reduction = "umap", group.by = "cell_type") & 
  labs(title="Original cell clusters")
```

```{r}
clust_summary <- se_embryo_orig@meta.data |> 
  select(seurat_clusters, cell_type) |> 
  group_by(seurat_clusters, cell_type) |> 
  summarise(n_cells = n())

clust_summary
```

```{r fig.height=4, fig.width=8}
p1 <- ggplot(clust_summary, aes(x = reorder(seurat_clusters, desc(seurat_clusters)), 
                          y = n_cells, fill = cell_type)) + 
  geom_bar(stat = "identity") +
  labs(x="Cluster", y="N cells") &
  coord_flip() &
  theme(legend.position = "right");p1

p2 <- ggplot(clust_summary, aes(x = reorder(seurat_clusters, desc(seurat_clusters)), 
                          y = n_cells, fill = cell_type)) + 
  geom_bar(position="fill", stat="identity") +
  labs(x="Cluster", y="Fraction") &
  coord_flip() &
  theme(legend.position = "right")

(p1 & theme(legend.position = "none")) | p2
```

Plot labels using original UMAP embedding

```{r fig.width=12, fig.height=7}
p_dat <- se_embryo_orig@meta.data

p1 <- ggplot(p_dat, aes(x=UMAP_1, y=UMAP_2, fill=cell_type)) +
  geom_point(shape=21, size=1, alpha=0.8) & 
  labs(title = "Original cell clusters")
  
p2 <- ggplot(p_dat, aes(x=UMAP_1, y=UMAP_2, fill=as.factor(seurat_clusters))) +
  geom_point(shape=21, size=1, alpha=0.8) & 
  labs(title = "New cell clusters")

(p1|p2) & 
  theme_linedraw() & 
  theme(aspect.ratio = 1, legend.position = "bottom", legend.title = element_blank()) &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 4))
```

## New cell data

Since no clear guidance on cell filtering steps were presented in the paper, I will try to deduce the type of filtering that was performed by looking at gene and UMI distributions, and other things such as percentage of mitochondrial counts.

```{r}
se_embryo[["percent.mt"]] <- PercentageFeatureSet(object = se_embryo, pattern = "^mt-")
se_embryo_orig[["percent.mt"]] <- PercentageFeatureSet(object = se_embryo_orig, pattern = "^mt-")
se_embryo_new[["percent.mt"]] <- PercentageFeatureSet(object = se_embryo_new, pattern = "^mt-")
```

```{r fig.width=10, fig.height=6}
VlnPlot(se_embryo, features = c("nCount_RNA", "nFeature_RNA", "percent.mt"), 
        group.by = "orig.ident") & theme(axis.title.x = element_blank()) |
  VlnPlot(se_embryo_orig, features = c("nCount_RNA", "nFeature_RNA", "percent.mt"), 
        group.by = "orig.ident") & theme(axis.title.x = element_blank())
```

```{r}
min_umi <- min(se_embryo$nCount_RNA);min_umi
min_gene <- min(se_embryo$nFeature_RNA);min_gene
max_mt <- max(se_embryo$percent.mt);max_mt

min_umi_orig <- min(se_embryo_orig$nCount_RNA);min_umi_orig
min_gene_orig <- min(se_embryo_orig$nFeature_RNA);min_gene_orig
max_mt_orig <- max(se_embryo_orig$percent.mt);max_mt_orig
```

Set filtering cutoffs to:

-   UMIs \>= 500 (min UMI in filtered data is 515)

-   Unique genes \> 250

-   Pct MT-genes \< 5

```{r}
se_embryo_new |> dim()
```

```{r}
cutoff_umi <- 500
cutoff_gene <- 250
cutoff_mt <- 5

se_embryo_new_filt <- subset(se_embryo_new,
                             nCount_RNA > cutoff_umi &
                               nFeature_RNA > cutoff_gene &
                               percent.mt < 8.5
                               )

se_embryo_new_filt |> dim()
```

### Process

```{r}
se_embryo_new_filt <- NormalizeData(se_embryo_new_filt, 
                                    scale.factor = 10000)
```

```{r}
se_embryo_new_filt <- FindVariableFeatures(se_embryo_new_filt, 
                                           nfeatures = 2000,
                                           selection.method = 'vst')
```

```{r}
se_embryo_new_filt <- ScaleData(se_embryo_new_filt, 
                                do.scale = T, 
                                do.center = T)
```

### Dim reduction & clustering

```{r}
se_embryo_new_filt <- RunPCA(se_embryo_new_filt)
```

```{r fig.width=6, fig.height=4}
ElbowPlot(se_embryo_new_filt, ndims = 50)
```

```{r fig.width=14, fig.height=18}
DimHeatmap(se_embryo_new_filt, reduction = "pca", dims = 1:30, ncol = 5)
DimHeatmap(se_embryo_new_filt, reduction = "pca", dims = 31:50, ncol = 5)
```

```{r}
# n_dims <- 30
n_dims <- 20
```

```{r}
se_embryo_new_filt <- RunUMAP(se_embryo_new_filt, 
                              dims = 1:n_dims, 
                              reduction = "pca", 
                              n.neighbors = 40, 
                              min.dist = 0.3, 
                              spread = 15, 
                              local.connectivity = 12)
```

```{r}
se_embryo_new_filt <- FindNeighbors(se_embryo_new_filt, dims = 1:n_dims, 
                                    reduction = "pca", compute.SNN = T)
se_embryo_new_filt <- FindClusters(se_embryo_new_filt, resolution = 0.8)
```

### Plot clusters

```{r fig.width=6, fig.height=6}
DimPlot(se_embryo_new_filt, reduction = "umap", group.by = "seurat_clusters", 
        cols = paletteer_d("ggsci::category20_d3", n = 20)) & labs(title="New cell clusters")
```

```{r fig.width=12, fig.height=6}
spat_data_new <- se_embryo_new_filt@meta.data

ggplot(spat_data_new, aes(x=align_recon_x_1, y=align_recon_y_1, fill=seurat_clusters)) +
  geom_point(shape=21) & 
  # scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
  labs(title = "Reconstructed positions and cell clusters", subtitle="New cell data") &
  theme_bw() &
  theme(aspect.ratio = 1, legend.position = "bottom") |
  ggplot(se_embryo_orig@meta.data, aes(x=align_recon_x_1, y=align_recon_y_1, fill=cell_type)) +
    geom_point(shape=21) & 
    # scale_fill_manual(values = paletteer_d("ggsci::category20_d3", n = 20)) &
    labs(title = "Reconstructed positions and original cell types", subtitle="Original cell data") &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "bottom")
```

### Integrate new cell data with original data and labels

```{r}
# Cell type colors
cell_types <- se_embryo_orig$cell_type |> unique() |> sort()
cell_type_colors <- c(
  hcl.colors(3, palette = "PinkYl"),
  hcl.colors(16, palette = "BuPu"),
  hcl.colors(4, palette = "Mint")[2:3]
)
```

#### Integration

Follow steps presented in this tutorial: https://satijalab.org/seurat/reference/findtransferanchors

```{r}
# find anchors
anchors <- FindTransferAnchors(reference = se_embryo_orig, query = se_embryo_new_filt)
```

```{r}
# transfer labels
predictions <- TransferData(
  anchorset = anchors,
  refdata = se_embryo_orig$cell_type
)
```

```{r}
se_embryo_new_filt <- AddMetaData(object = se_embryo_new_filt, metadata = predictions)
```

Save cell type and pre score output for all new cells.

```{r}
out_dat <- se_embryo_new_filt@meta.data
out_dat$node_bc <- rownames(out_dat)
out_dat$node_type <- out_dat$predicted.id

out_dat <- out_dat |> 
  select(node_bc, node_type, starts_with("prediction.score."), 
         starts_with("recon_"), starts_with("align_recon"))

write.csv(out_dat, 
          file = file.path(DIR_RES, "embryo_recon_gated_new_cell_predictions_metadata.csv"), 
          row.names = F)
```

#### Plot results

```{r fig.width=16, fig.height=6}
ggplot(se_embryo_new_filt@meta.data, aes(x=align_recon_x_1, y=align_recon_y_1, fill=predicted.id)) +
  geom_point(shape=21) & 
  scale_fill_manual(values = cell_type_colors) &
  labs(title = "Reconstructed positions and predicted cell types", subtitle="New cell data") &
  theme_bw() &
  theme(aspect.ratio = 1, legend.position = "none") |
  ggplot(se_embryo_orig@meta.data, aes(x=align_recon_x_1, y=align_recon_y_1, fill=cell_type)) +
    geom_point(shape=21) & 
    scale_fill_manual(values = cell_type_colors) &
    labs(title = "Reconstructed positions and original cell types", subtitle="Original cell data") &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "none", legend.title = element_blank()) &
    guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1)) |
  ggplot(se_embryo_orig@meta.data, aes(x=spatial_x, y=spatial_y, fill=cell_type)) +
    geom_point(shape=21) & 
    scale_fill_manual(values = cell_type_colors) &
    labs(title = "Reconstructed positions and original cell types", subtitle="Original cell data") &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "right", legend.title = element_blank()) &
    guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))
```

UMAP

```{r}
se_embryo_new_filt <- AddMetaData(se_embryo_new_filt, 
                                  metadata = se_embryo_new_filt@reductions$umap@cell.embeddings, 
                                  col.name = c("UMAP_1", "UMAP_2"))
```

```{r fig.width=12, fig.height=6}
p1 <- ggplot(se_embryo_new_filt@meta.data, aes(x=UMAP_1, y=UMAP_2, fill=predicted.id)) +
  geom_point(shape=21, size=1, alpha=0.8) & 
  scale_fill_manual(values = cell_type_colors) &
  labs(title = "Reconstructed positions and predicted cell types", subtitle="New cell data") &
  theme_linedraw() & 
  theme(aspect.ratio = 1, legend.position = "none")
  
p2 <- ggplot(se_embryo_orig@meta.data, aes(x=UMAP_1, y=UMAP_2, fill=as.factor(cell_type))) +
  geom_point(shape=21, size=1, alpha=0.8) & 
  scale_fill_manual(values = cell_type_colors) &
    labs(title = "Reconstructed positions and original cell types", subtitle="Original cell data") & 
  theme_linedraw() & 
  theme(aspect.ratio = 1, legend.position = "right", legend.title = element_blank()) &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))

(p1|p2)
```

Plot spatial, one cluster at the time

```{r}
p_data1 <- se_embryo_new_filt@meta.data
p_data2 <- se_embryo_orig@meta.data

colnames(p_data1) <- gsub(" ", "_", colnames(p_data1))
colnames(p_data2) <- gsub(" ", "_", colnames(p_data2))
p_data1$cell_type <- gsub(" ", "_", p_data1$predicted.id)
p_data2$cell_type <- gsub(" ", "_", p_data2$cell_type)

cell_types <- p_data2$cell_type |> unique() |> sort()
cell_colors <- rep("grey95", length(cell_types))
```

```{r}
x_transform <- 1
y_transform <- 1
p_data1$recon_x <- p_data1$align_recon_x_1 * x_transform
p_data1$recon_y <- p_data1$align_recon_y_1 * y_transform

p_data2$recon_x <- p_data2$align_recon_x_1 * x_transform
p_data2$recon_y <- p_data2$align_recon_y_1 * y_transform
```

```{r fig.width=14, fig.height=4}
cell <- cell_types[1]
cell_colors[1] <- cell_type_colors[1]

p1 <- ggplot(subset(p_data1, predicted.id==cell), aes(x=recon_x, y=recon_y, 
                                                      fill=prediction.score.Radial.glia)) +
  geom_point(shape=21) & 
  scale_fill_manual(values = cell_colors) &
  labs(title = paste(cell, "| New cell data"), fill="Pred. score") &
  theme_bw() &
  theme(aspect.ratio = 1, legend.position = "bottom")
p2 <- ggplot(subset(p_data2, cell_type==cell), aes(x=recon_x, y=recon_y, fill=cell_type)) +
  geom_point(shape=21) & 
  scale_fill_manual(values = cell_colors) &
  labs(title = paste(cell, "| Original cell data (recon)")) &
  theme_bw() &
  theme(aspect.ratio = 1, legend.position = "none", legend.title = element_blank()) &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))
p3 <- ggplot(subset(p_data2, cell_type==cell), aes(x=spatial_x, y=spatial_y, fill=cell_type)) +
  geom_point(shape=21) & 
  scale_fill_manual(values = cell_colors) &
  labs(title = paste(cell, "| Original cell data (gt)")) &
  theme_bw() &
  theme(aspect.ratio = 1, legend.position = "none", legend.title = element_blank()) &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))

(p1|p2|p3)
```

```{r fig.width=22, fig.height=30}
p_list <- list()
p_list <- lapply(1:length(cell_types), function(i){
  cell <- cell_types[i]
  # cell_colors[i] <- paletteer_d("ggsci::category20_d3", n = 20)[i]
  cell_colors <- cell_type_colors[i]
  p1 <- ggplot(subset(p_data1, predicted.id==cell), aes_string(x="recon_x", y="recon_y", 
                                                               fill="cell_type")) +
    geom_point(shape=21) & 
    scale_fill_manual(values = cell_colors) &
    # scale_fill_paletteer_c("grDevices::Purple-Yellow", direction = -1) &
    labs(title = paste(cell, "| New cell data"), fill="Pred. score") &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "none")
  p2 <- ggplot(subset(p_data2, cell_type==cell), aes(x=recon_x, y=recon_y, fill=cell_type)) +
    geom_point(shape=21) & 
    scale_fill_manual(values = cell_colors) &
    labs(title = paste(cell, "| Original cell data (recon)")) &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "none", legend.title = element_blank()) &
    guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))
  p3 <- ggplot(subset(p_data2, cell_type==cell), aes(x=spatial_x, y=spatial_y, fill=cell_type)) +
    geom_point(shape=21) & 
    scale_fill_manual(values = cell_colors) &
    labs(title = paste(cell, "| Original cell data (gt)")) &
    theme_bw() &
    theme(aspect.ratio = 1, legend.position = "none", legend.title = element_blank()) &
    guides(fill = guide_legend(override.aes = list(size = 3), ncol = 1))
  return(p1|p2|p3)
})

patchwork::wrap_plots(p_list, ncol = 2)
```

```{r}
# Save to PDF
pdf(file = file.path(DIR_RES, "embryo_recon_gated_new_cell_predictions_spatial_split.pdf"), width = 22, height = 30)
patchwork::wrap_plots(p_list, ncol = 2)
dev.off()
```

#### Describe added cells and their properties

Compute cell type abundances/proportions

```{r}
prop_cell_orig <- se_embryo_orig@meta.data |> 
  group_by(cell_type) |> 
  summarise(n_cells_orig = n(),
            freq_cells_orig = n()/nrow(se_embryo_orig@meta.data)) |> 
  mutate(pct_cells_orig = freq_cells_orig*100)

prop_cell_new <- se_embryo_new_filt@meta.data |> 
  group_by(predicted.id) |> 
  summarise(n_cells_new = n(),
            freq_cells_new = n()/nrow(se_embryo_new_filt@meta.data)) |> 
  mutate(pct_cells_new = freq_cells_new*100,
         cell_type = predicted.id) |> 
  select(-predicted.id)

prop_cell <- merge(prop_cell_orig, prop_cell_new, by="cell_type")
prop_cell
```

Plot

```{r}
prop_cell_long <- pivot_longer(prop_cell, 
                               cols = starts_with("pct_cells_"),
                               names_to = "dataset", 
                               names_prefix = "pct_cells_",
                               values_to = "pct")
```

```{r}
prop_cell$pct_diff <- prop_cell$pct_cells_new - prop_cell$pct_cells_orig
```

```{r fig.width=7, fig.height=5}
p1 <- ggplot(prop_cell_long, aes(x = reorder(cell_type, n_cells_orig), y = pct, fill = dataset)) + 
  geom_hline(yintercept = 0, linewidth=0.25) +
  geom_bar(position="dodge", stat="identity", width = 0.8) +
  scale_fill_manual(values = c("#1F77B4FF", "#9EDAE5FF")) + # paletteer_d("ggsci::category20_d3", n = 2)
  labs(x="Cell type", y="Percent of total cells") +
  coord_flip() +
  theme_bw() +
  theme(legend.position = "top")

p2 <- ggplot(prop_cell, aes(x = reorder(cell_type, pct_diff), y = pct_diff, fill = cell_type)) + 
  geom_hline(yintercept = 0, linewidth=0.25) +
  geom_bar(stat="identity", width = 0.8, color="grey20", linewidth=0.25) +
  scale_fill_manual(values = cell_type_colors) +
  labs(x="", y="Percent difference\n(new-orig)") +
  coord_flip() +
  theme_bw() +
  theme(legend.position = "none")

p1|p2
```

Look at number of genes, UMIs, and pct-mt in the newly added cells - compare with original cells

```{r fig.width=6, fig.height=4}
VlnPlot(se_embryo_new_filt, features = "nCount_RNA", group.by = "predicted.id") & 
  # geom_hline(yintercept = 1e3, style="dashed") &
  scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none") | 
  VlnPlot(se_embryo_orig, features = "nCount_RNA", group.by = "cell_type") & 
  scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none")


VlnPlot(se_embryo_new_filt, features = "nFeature_RNA", group.by = "predicted.id") & 
  scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none") | 
  VlnPlot(se_embryo_orig, features = "nFeature_RNA", group.by = "cell_type") & 
  scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none")


VlnPlot(se_embryo_new_filt, features = "percent.mt", group.by = "predicted.id") & 
  # scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none") | 
  VlnPlot(se_embryo_orig, features = "percent.mt", group.by = "cell_type") & 
  # scale_y_log10() &
  coord_flip() &
  theme_bw() &
  theme(axis.title.y = element_blank(), legend.position = "none")
```

## Spatial analysis assessment and comparison

Prepare data to be processed and analysed with Squidpy instead

### Export data for squidpy

To create an AnnData object, we need the count matrix, coordinates, and metadata

```{r}
# devtools::install_github("satijalab/seurat-data") # not needed?
# devtools::install_github("mojaveazure/seurat-disk") # contains the SaveH5Seurat function
```

```{r}
# library(SeuratData)
library(SeuratDisk)
```

**Original cell data**

Ground truth (gt) and reconstructed (rc) coordinates

```{r}
se_embryo_orig@meta.data[se_embryo_orig$align_recon_x_1=="NA",]
```

```{r}
se_export_orig_gt <- se_export_orig_rc <- se_embryo_orig

# If the non-scaled data should be imported to squidpy, it needs to be overwritten with the normalized data
se_export_orig_gt@assays$RNA@scale.data <- se_export_orig_gt@assays$RNA@data[VariableFeatures(se_export_orig_gt), ] |>
  as.matrix()
se_export_orig_rc@assays$RNA@scale.data <- se_export_orig_rc@assays$RNA@data[VariableFeatures(se_export_orig_rc), ] |>
  as.matrix()

se_export_orig_rc$spatial_x <- se_export_orig_rc$align_recon_x_1
se_export_orig_rc$spatial_y <- se_export_orig_rc$align_recon_y_1

cols_remove <- se_export_orig_rc@meta.data |> select(contains("recon_x_")) |> colnames()
cols_remove <- c(cols_remove, se_export_orig_rc@meta.data |> select(contains("recon_y_")) |> colnames())

se_export_orig_rc@meta.data <- se_export_orig_rc@meta.data[, -which(colnames(se_export_orig_rc@meta.data) %in% cols_remove)]
se_export_orig_gt@meta.data <- se_export_orig_gt@meta.data[, -which(colnames(se_export_orig_gt@meta.data) %in% cols_remove)]
```

```{r}
SaveH5Seurat(se_export_orig_gt, filename = file.path(DIR_RES, "se_data_orig_cells_gt.h5Seurat"), overwrite = T)
Convert(file.path(DIR_RES, "se_data_orig_cells_gt.h5Seurat"), dest = "h5ad", overwrite = T)
```

```{r}
SaveH5Seurat(se_export_orig_rc, filename = file.path(DIR_RES, "se_data_orig_cells_rc.h5Seurat"), overwrite = T)
Convert(file.path(DIR_RES, "se_data_orig_cells_rc.h5Seurat"), dest = "h5ad", overwrite = T)
```

**New cell data**

```{r}
se_export_new <- se_embryo_new_filt
se_export_new$cell_type <- se_export_new$predicted.id
se_export_new$spatial_x <- se_export_new$align_recon_x_1
se_export_new$spatial_y <- se_export_new$align_recon_y_1

DefaultAssay(se_export_new)

cols_remove <- se_embryo_new_filt@meta.data |> select(contains("recon_x_")) |> colnames()
cols_remove <- c(cols_remove, se_embryo_new_filt@meta.data |> select(contains("recon_y_")) |> colnames())

se_export_new@meta.data <- se_export_new@meta.data[, -which(colnames(se_export_new@meta.data) %in% cols_remove)]
```

```{r}
SaveH5Seurat(se_export_new, 
             filename = file.path(DIR_RES, "se_data_new_cells_filt.h5Seurat"), 
             overwrite = T)
Convert(file.path(DIR_RES, "se_data_new_cells_filt.h5Seurat"), dest = "h5ad", overwrite = T)
```

```{r}
file.path(DIR_RES, "se_data_new_cells_filt.h5ad")
```




### TO DO - Import squidpy analysis results

#### Neighborhood enrichment analysis

```{r}
library(pheatmap)
```

```{r}
nb_cells <- read_csv('/Users/lovisafranzen/Documents/PhD_Projects/slide-tags_hidden-network/slidetags-network/results/mouse_embryonic_brain/nhood_cells.csv',
                     show_col_types = FALSE, col_names = F) |> pull(X1)
nb_cells
```

```{r}
nb_orig_gt <- read_csv('/Users/lovisafranzen/Documents/PhD_Projects/slide-tags_hidden-network/slidetags-network/results/mouse_embryonic_brain/nhood_stats_orig_gt.csv',
                       col_names = F) |> as.matrix()

nb_orig_rc <- read_csv('/Users/lovisafranzen/Documents/PhD_Projects/slide-tags_hidden-network/slidetags-network/results/mouse_embryonic_brain/nhood_stats_orig_rc.csv',
                       col_names = F) |> as.matrix()

nb_new_rc <- read_csv('/Users/lovisafranzen/Documents/PhD_Projects/slide-tags_hidden-network/slidetags-network/results/mouse_embryonic_brain/nhood_stats_new_rc.csv',
                       col_names = F) |> as.matrix()
```

```{r}
nb_cells_ordered <- c('B_germinal_center', 'B_memory', 'B_naive', 'FDC', 'NK', 'T_CD4', 'T_CD8', 'T_double_neg', 'T_follicular_helper', 'mDC', 'myeloid', 'pDC', 'plasma')
nb_cells_ordered <- gsub("_", "-", nb_cells_ordered)
```

```{r}
n_cells <- length(nb_cells_ordered)
ph_group_colors <- list(cell = setNames(paletteer::paletteer_d("ggsci::category20_d3", n = n_cells) |> as.character(), 
                                         nm = nb_cells_ordered))
ph_groups <- data.frame(row.names = nb_cells_ordered, cell = nb_cells_ordered)
```

```{r fig.width=4, fig.height=4}
plt_nb_orig_gt <- nb_orig_gt
rownames(plt_nb_orig_gt) <- colnames(plt_nb_orig_gt) <- nb_cells_ordered

paletteLength <- 50
# myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
# myColor <- RColorBrewer::brewer.pal(n = paletteLength, name = "RdBu") |> rev()
myColor <- colorRampPalette(RColorBrewer::brewer.pal(n = 11, name = "RdBu"))(paletteLength) |> rev()
myBreaks <- c(seq(min(plt_nb_orig_gt), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(plt_nb_orig_gt)/paletteLength, max(plt_nb_orig_gt), length.out=floor(paletteLength/2)))

pheatmap(plt_nb_orig_gt, 
         # color = viridis::viridis(n = 10), 
         color = myColor, breaks = myBreaks, 
         annotation_col = ph_groups, annotation_row = ph_groups, annotation_colors = ph_group_colors, annotation_legend = F,
         cellwidth = 10, cellheight = 10, 
         cluster_rows=FALSE, cluster_cols=FALSE,
         treeheight_row = 10, treeheight_col = 10, 
         main = "Nbh enrichment | orig-gt",
         border_color = NA)
```

```{r fig.width=4, fig.height=4}
plt_nb_orig_rc <- nb_orig_rc
rownames(plt_nb_orig_rc) <- colnames(plt_nb_orig_rc) <- nb_cells_ordered

paletteLength <- 50
myColor <- colorRampPalette(RColorBrewer::brewer.pal(n = 11, name = "RdBu") |> rev())(paletteLength)
myBreaks <- c(seq(min(plt_nb_orig_rc), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(plt_nb_orig_rc)/paletteLength, max(plt_nb_orig_rc), length.out=floor(paletteLength/2)))

pheatmap(plt_nb_orig_rc, 
         color = myColor, breaks = myBreaks,
         annotation_col = ph_groups, annotation_row = ph_groups, annotation_colors = ph_group_colors, annotation_legend = F,
         cellwidth = 10, cellheight = 10, 
         cluster_rows=FALSE, cluster_cols=FALSE,
         treeheight_row = 10, treeheight_col = 10, 
         main = "Nbh enrichment | orig-rc",
         border_color = NA)
```

```{r fig.width=4, fig.height=4}
plt_nb_new_rc <- nb_new_rc
rownames(plt_nb_new_rc) <- colnames(plt_nb_new_rc) <- nb_cells_ordered

paletteLength <- 50
myColor <- colorRampPalette(RColorBrewer::brewer.pal(n = 11, name = "RdBu") |> rev())(paletteLength)
myBreaks <- c(seq(min(plt_nb_new_rc), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(plt_nb_new_rc)/paletteLength, max(plt_nb_new_rc), length.out=floor(paletteLength/2)))

pheatmap(plt_nb_new_rc, 
         color = myColor, breaks = myBreaks,
         annotation_col = ph_groups, annotation_row = ph_groups, annotation_colors = ph_group_colors, annotation_legend = F,
         cellwidth = 10, cellheight = 10, 
         cluster_rows=FALSE, cluster_cols=FALSE,
         # treeheight_row = 10, treeheight_col = 10, 
         main = "Nbh enrichment | new-rc",
         border_color = NA)
```

Compute differences between gt-pos and recon-pos neighborhood enrichment data.

```{r}
plt_nb_orig_diff <- abs(plt_nb_orig_gt - plt_nb_orig_rc)
```

```{r fig.width=4, fig.height=4}
pheatmap(plt_nb_orig_diff, 
         color = viridis::viridis(n = 10), 
         breaks = seq(0, 10, 1),
         # color = myColor, breaks = myBreaks,
         cellwidth = 10, cellheight = 10, 
         cluster_rows=FALSE, cluster_cols=FALSE,
         # treeheight_row = 10, treeheight_col = 10, 
         main = "Absolute diff (score)",
         border_color = NA)
```

```{r}
plt_nb_orig_diff_tbl <- plt_nb_orig_diff |> as.data.frame() |> rownames_to_column("cell1")
plt_nb_orig_diff_long <- pivot_longer(plt_nb_orig_diff_tbl, cols = -c("cell1"), names_to = "cell2", values_to = "diff")  
plt_nb_orig_diff_long$cell_pair <- paste0(plt_nb_orig_diff_long$cell1, "_", plt_nb_orig_diff_long$cell2)
```

```{r fig.width=6, fig.height=6}
ggplot(plt_nb_orig_diff_long, aes(x=reorder(cell_pair, diff), y=diff)) +
  geom_col(width=1) + 
  coord_flip() +
  theme(axis.text.y = element_blank())
```






## SessionInfo

```{r}
sessionInfo()
```
